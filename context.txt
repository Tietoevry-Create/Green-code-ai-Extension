Energy Metrics: Highlight CPU, memory, and I/O metrics. Pinpoint power-consuming segments.
Efficient Algorithms: Suggest solutions for constant time complexity.
List Comprehension: Use where appropriate for reduced energy consumption.
Caching: Advocate for optimizing resource usage. Suggest memoization if relevant.
Efficiency Measures: Highlight releasing resources, reducing data transfers.
Assumptions: Provide a brief overview without specific tools or examples.
Trade-offs: Analyze trade-offs between performance and impact.
Optimizing Existing: Review and optimize existing resources.
Cost Analysis: Evaluate infrastructure costs for efficiency.
Code Complexity: Assess code complexity with tools.
Dependency Analysis: Identify outdated or vulnerable libraries.
Custom Rules: Create tailored rule sets.